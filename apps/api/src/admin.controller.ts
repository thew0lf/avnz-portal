import { Controller, Get, Post, Patch, Delete, Param, Body, BadRequestException, Query, UseGuards } from '@nestjs/common'
import { pool } from './db.js'
import { Authz, RbacGuard } from './authz/rbac.guard.js'
import { audit } from './audit.js'

@Controller('admin')
@UseGuards(RbacGuard)
export class AdminController {
  // Security settings
  @Get('security-settings') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' })
  async getSec(@Query('nodeId') _nodeId?:string){ const c=await pool.connect(); try{ const r=await c.query('select require_mfa,password_policy,audit_retention_days from security_settings where id=1'); return r.rows[0] } finally { c.release() } }
  @Patch('security-settings') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' })
  async setSec(@Body() b:any, @Query('nodeId') _nodeId?:string){ const { require_mfa, password_policy, audit_retention_days }=b||{}; const c=await pool.connect(); try{ await c.query('update security_settings set require_mfa=coalesce($1,require_mfa), password_policy=coalesce($2::jsonb,password_policy), audit_retention_days=coalesce($3,audit_retention_days), updated_at=now() where id=1',[require_mfa, password_policy? JSON.stringify(password_policy): null, audit_retention_days||null]); return { ok:true } } finally { c.release() } }

  // Route registry CRUD
  @Get('routes') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' })
  async listRoutes(@Query('nodeId') _nodeId?:string, @Query('q') q?:string, @Query('limit') limit?:string, @Query('offset') offset?:string){ const c=await pool.connect(); try{ const lim=Math.max(1, Math.min(200, Number(limit||'20'))); const off=Math.max(0, Number(offset||'0')); let sql='select id,method,path,domain,resource_type,action_name,resource_param from authz.route_registry'; const args:any[]=[]; if (q){ args.push(`%${q.toLowerCase()}%`); sql+=' where lower(path) like $1' } sql+=' order by path limit '+lim+' offset '+off; const r=await c.query(sql,args); return { rows:r.rows, limit:lim, offset:off, q:q||'' } } finally{ c.release() } }
  @Post('routes') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' })
  async createRoute(@Body() b:any, @Query('nodeId') _nodeId?:string, req?:any){ const { id,method,path,domain,resource_type,action_name,resource_param }=b||{}; if(!method||!path||!domain||!resource_type||!action_name) throw new BadRequestException('missing'); const c=await pool.connect(); try{ const r=await c.query('insert into authz.route_registry(id,method,path,domain,resource_type,action_name,resource_param) values (coalesce($1,gen_random_uuid()),$2,$3,$4,$5,$6,$7) on conflict (method,path) do update set domain=excluded.domain, resource_type=excluded.resource_type, action_name=excluded.action_name, resource_param=excluded.resource_param returning id,method,path,domain,resource_type,action_name,resource_param',[id||null, method.toUpperCase(), path, domain, resource_type, action_name, resource_param||null]); await audit(req as any,'upsert','authz.route', r.rows[0]?.id, null, r.rows[0]); return r.rows[0] } finally{ c.release() } }
  @Delete('routes/:id') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' })
  async deleteRoute(@Param('id') id:string, @Query('nodeId') _nodeId?:string, req?:any){ const c=await pool.connect(); try{ const before=(await c.query('select * from authz.route_registry where id=$1',[id])).rows[0]; await c.query('delete from authz.route_registry where id=$1',[id]); await audit(req as any,'delete','authz.route', id, before, null); return { ok:true } } finally{ c.release() } }
  // Roles
  @Get('roles') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async listRoles(@Query('nodeId') _nodeId?:string, @Query('q') q?:string, @Query('limit') limit?:string, @Query('offset') offset?:string){ const c=await pool.connect(); try{ const lim=Math.max(1, Math.min(200, Number(limit||'20'))); const off=Math.max(0, Number(offset||'0')); let sql='select id,name,level from authz.roles'; const args:any[]=[]; if (q){ args.push(`%${q.toLowerCase()}%`); sql+=' where lower(name) like $1' } sql+=' order by level desc limit '+lim+' offset '+off; const r=await c.query(sql,args); return { rows:r.rows, limit: lim, offset: off, q: q||'' } } finally{ c.release() } }
  @Post('roles') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async createRole(@Body() b:any, @Query('nodeId') _nodeId?:string, @Param() _p?:any, @Query() _q?:any, @Body() _body2?:any, req?:any){ const { id,name,level }=b||{}; if(!name||typeof level!=='number') throw new BadRequestException('name, level required'); const c=await pool.connect(); try{ const r=await c.query('insert into authz.roles(id,name,level) values (coalesce($1,gen_random_uuid()),$2,$3) returning id,name,level',[id||null,name,level]); await audit(req as any,'create','authz.role',r.rows[0]?.id,null,r.rows[0]); return r.rows[0] } finally{ c.release() } }
  @Patch('roles/:id') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async updateRole(@Param('id') id:string,@Body() b:any, @Query('nodeId') _nodeId?:string, req?:any){ const { name,level }=b||{}; if(!name&&typeof level!=='number') throw new BadRequestException('nothing to update'); const c=await pool.connect(); try{ const before = (await c.query('select id,name,level from authz.roles where id=$1',[id])).rows[0]; const r=await c.query('update authz.roles set name=coalesce($2,name), level=coalesce($3,level) where id=$1 returning id,name,level',[id,name||null,typeof level==='number'?level:null]); const row=r.rows[0]; if(!row) throw new BadRequestException('not found'); await audit(req as any,'update','authz.role',id,before,row); return row } finally{ c.release() } }
  @Delete('roles/:id') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async deleteRole(@Param('id') id:string, @Query('nodeId') _nodeId?:string, req?:any){ const c=await pool.connect(); try{ const before=(await c.query('select id,name,level from authz.roles where id=$1',[id])).rows[0]; await c.query('delete from authz.roles where id=$1',[id]); await audit(req as any,'delete','authz.role',id,before,null); return { ok:true } } finally{ c.release() } }

  // Actions
  @Get('actions') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async listActions(@Query('nodeId') _nodeId?:string, @Query('q') q?:string, @Query('limit') limit?:string, @Query('offset') offset?:string){ const c=await pool.connect(); try{ const lim=Math.max(1, Math.min(200, Number(limit||'20'))); const off=Math.max(0, Number(offset||'0')); let sql='select name from authz.actions'; const args:any[]=[]; if (q){ args.push(`%${q.toLowerCase()}%`); sql+=' where lower(name) like $1' } sql+=' order by name asc limit '+lim+' offset '+off; const r=await c.query(sql,args); return { rows:r.rows, limit: lim, offset: off, q: q||'' } } finally{ c.release() } }
  @Post('actions') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async createAction(@Body() b:any, @Query('nodeId') _nodeId?:string, req?:any){ const { name }=b||{}; if(!name) throw new BadRequestException('name required'); const c=await pool.connect(); try{ const r=await c.query('insert into authz.actions(name) values ($1) on conflict do nothing returning name',[name]); await audit(req as any,'create','authz.action',name,null,r.rows[0]||{name}); return r.rows[0]||{name} } finally{ c.release() } }
  @Delete('actions/:name') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async deleteAction(@Param('name') name:string, @Query('nodeId') _nodeId?:string, req?:any){ const c=await pool.connect(); try{ await c.query('delete from authz.actions where name=$1',[name]); await audit(req as any,'delete','authz.action',name,null,null); return { ok:true } } finally{ c.release() } }

  // Permissions
  @Get('permissions') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async listPerms(@Query('nodeId') _nodeId?:string, @Query('q') q?:string, @Query('limit') limit?:string, @Query('offset') offset?:string){ const c=await pool.connect(); try{ const lim=Math.max(1, Math.min(200, Number(limit||'20'))); const off=Math.max(0, Number(offset||'0')); let sql='select id,domain,resource_type,action_name,min_role_id from authz.permissions'; const args:any[]=[]; if (q){ args.push(`%${q.toLowerCase()}%`); sql+=" where lower(domain)||'.'||lower(resource_type)||'.'||lower(action_name) like $1" } sql+=' order by domain,resource_type,action_name limit '+lim+' offset '+off; const r=await c.query(sql,args); return { rows:r.rows, limit: lim, offset: off, q: q||'' } } finally{ c.release() } }
  @Post('permissions') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async createPerm(@Body() b:any, @Query('nodeId') _nodeId?:string, req?:any){ const { id,domain,resource_type,action_name,min_role_id }=b||{}; if(!domain||!resource_type||!action_name||!min_role_id) throw new BadRequestException('missing fields'); const c=await pool.connect(); try{ const before=(await c.query('select id,domain,resource_type,action_name,min_role_id from authz.permissions where domain=$1 and resource_type=$2 and action_name=$3',[domain,resource_type,action_name])).rows[0]; const r=await c.query('insert into authz.permissions(id,domain,resource_type,action_name,min_role_id) values (coalesce($1,gen_random_uuid()),$2,$3,$4,$5) on conflict (domain,resource_type,action_name) do update set min_role_id=excluded.min_role_id returning id,domain,resource_type,action_name,min_role_id',[id||null,domain,resource_type,action_name,min_role_id]); await audit(req as any, before? 'update':'create','authz.permission', r.rows[0]?.id, before, r.rows[0]); return r.rows[0] } finally{ c.release() } }
  @Patch('permissions/:id') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async updatePerm(@Param('id') id:string,@Body() b:any, @Query('nodeId') _nodeId?:string, req?:any){ const { min_role_id }=b||{}; if(!min_role_id) throw new BadRequestException('min_role_id required'); const c=await pool.connect(); try{ const before=(await c.query('select id,domain,resource_type,action_name,min_role_id from authz.permissions where id=$1',[id])).rows[0]; const r=await c.query('update authz.permissions set min_role_id=$2 where id=$1 returning id,domain,resource_type,action_name,min_role_id',[id,min_role_id]); const row=r.rows[0]; if(!row) throw new BadRequestException('not found'); await audit(req as any,'update','authz.permission',id,before,row); return row } finally{ c.release() } }
  @Delete('permissions/:id') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async deletePerm(@Param('id') id:string, @Query('nodeId') _nodeId?:string, req?:any){ const c=await pool.connect(); try{ const before=(await c.query('select id,domain,resource_type,action_name,min_role_id from authz.permissions where id=$1',[id])).rows[0]; await c.query('delete from authz.permissions where id=$1',[id]); await audit(req as any,'delete','authz.permission',id,before,null); return { ok:true } } finally{ c.release() } }

  // Role assignments
  @Get('assignments') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async listAssignments(@Query('userId') userId?:string,@Query('nodeId') nodeId?:string, @Query('limit') limit?:string, @Query('offset') offset?:string){ const c=await pool.connect(); try{ const lim=Math.max(1, Math.min(200, Number(limit||'20'))); const off=Math.max(0, Number(offset||'0')); let where=''; const args:any[]=[]; if(userId){args.push(userId); where+=' where user_id=$'+args.length} if(nodeId){args.push(nodeId); where+=(where?' and':' where')+' node_id=$'+args.length} const r=await c.query(`select id,user_id,node_id,role_id,constraints from authz.role_assignments${where} order by user_id,node_id limit ${lim} offset ${off}`,args); return { rows:r.rows, limit:lim, offset:off } } finally{ c.release() } }
  @Post('assignments') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async createAssignment(@Body() b:any, @Query('nodeId') _nodeId?:string, req?:any){ const { id,user_id,node_id,role_id,constraints }=b||{}; if(!user_id||!node_id||!role_id) throw new BadRequestException('missing fields'); const c=await pool.connect(); try{ const r=await c.query('insert into authz.role_assignments(id,user_id,node_id,role_id,constraints) values (coalesce($1,gen_random_uuid()),$2,$3,$4,coalesce($5,\'{}\'::jsonb)) on conflict do nothing returning id,user_id,node_id,role_id,constraints',[id||null,user_id,node_id,role_id,JSON.stringify(constraints||{})]); const out = r.rows[0] || { id, user_id, node_id, role_id, constraints: constraints || {} }; await audit(req as any,'create','authz.role_assignment', out.id, null, out); return out } finally{ c.release() } }
  @Delete('assignments/:id') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async deleteAssignment(@Param('id') id:string, @Query('nodeId') _nodeId?:string, req?:any){ const c=await pool.connect(); try{ const before=(await c.query('select * from authz.role_assignments where id=$1',[id])).rows[0]; await c.query('delete from authz.role_assignments where id=$1',[id]); await audit(req as any,'delete','authz.role_assignment', id, before, null); return { ok:true } } finally{ c.release() } }

  // ABAC fences
  @Get('abac') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async listAbac(@Query('nodeId') _nodeId?:string){ const c=await pool.connect(); try{ const r=await c.query('select id,action_name,expr from authz.abac_fences order by action_name'); return { rows:r.rows } } finally{ c.release() } }
  @Post('abac') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async createAbac(@Body() b:any, @Query('nodeId') _nodeId?:string, req?:any){ const { id,action_name,expr }=b||{}; if(!action_name||!expr) throw new BadRequestException('missing fields'); const c=await pool.connect(); try{ const r=await c.query('insert into authz.abac_fences(id,action_name,expr) values (coalesce($1,gen_random_uuid()),$2,$3::jsonb) returning id,action_name,expr',[id||null,action_name,JSON.stringify(expr)]); await audit(req as any,'create','authz.abac',r.rows[0]?.id,null,r.rows[0]); return r.rows[0] } finally{ c.release() } }
  @Patch('abac/:id') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async updateAbac(@Param('id') id:string,@Body() b:any, @Query('nodeId') _nodeId?:string, req?:any){ const { expr }=b||{}; if(!expr) throw new BadRequestException('expr required'); const c=await pool.connect(); try{ const before=(await c.query('select * from authz.abac_fences where id=$1',[id])).rows[0]; const r=await c.query('update authz.abac_fences set expr=$2::jsonb where id=$1 returning id,action_name,expr',[id,JSON.stringify(expr)]); const row=r.rows[0]; if(!row) throw new BadRequestException('not found'); await audit(req as any,'update','authz.abac',id,before,row); return row } finally{ c.release() } }
  @Delete('abac/:id') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async deleteAbac(@Param('id') id:string, @Query('nodeId') _nodeId?:string, req?:any){ const c=await pool.connect(); try{ const before=(await c.query('select * from authz.abac_fences where id=$1',[id])).rows[0]; await c.query('delete from authz.abac_fences where id=$1',[id]); await audit(req as any,'delete','authz.abac',id,before,null); return { ok:true } } finally{ c.release() } }
}
