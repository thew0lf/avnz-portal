import { Controller, Get, Post, Patch, Delete, Param, Body, BadRequestException, Query, UseGuards } from '@nestjs/common'
import { pool } from './db.js'
import { Authz, RbacGuard } from './authz/rbac.guard.js'
import { audit } from './audit.js'
import { enc } from './crypto.util.js'

@Controller('admin')
@UseGuards(RbacGuard)
export class AdminController {
  // Security settings
  @Get('security-settings') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' })
  async getSec(@Query('nodeId') _nodeId?:string){ const c=await pool.connect(); try{ const r=await c.query('select require_mfa,password_policy,audit_retention_days from security_settings where id=1'); return r.rows[0] } finally { c.release() } }
  @Patch('security-settings') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' })
  async setSec(@Body() b:any, @Query('nodeId') _nodeId?:string){ const { require_mfa, password_policy, audit_retention_days }=b||{}; const c=await pool.connect(); try{ await c.query('update security_settings set require_mfa=coalesce($1,require_mfa), password_policy=coalesce($2::jsonb,password_policy), audit_retention_days=coalesce($3,audit_retention_days), updated_at=now() where id=1',[require_mfa, password_policy? JSON.stringify(password_policy): null, audit_retention_days||null]); return { ok:true } } finally { c.release() } }

  // Route registry CRUD
  @Get('routes') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' })
  async listRoutes(@Query('nodeId') _nodeId?:string, @Query('q') q?:string, @Query('limit') limit?:string, @Query('offset') offset?:string){ const c=await pool.connect(); try{ const lim=Math.max(1, Math.min(200, Number(limit||'20'))); const off=Math.max(0, Number(offset||'0')); let sql='select id,method,path,domain,resource_type,action_name,resource_param from authz.route_registry'; const args:any[]=[]; if (q){ args.push(`%${q.toLowerCase()}%`); sql+=' where lower(path) like $1' } sql+=' order by path limit '+lim+' offset '+off; const r=await c.query(sql,args); return { rows:r.rows, limit:lim, offset:off, q:q||'' } } finally{ c.release() } }
  @Post('routes') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' })
  async createRoute(@Body() b:any, @Query('nodeId') _nodeId?:string, req?:any){ const { id,method,path,domain,resource_type,action_name,resource_param }=b||{}; if(!method||!path||!domain||!resource_type||!action_name) throw new BadRequestException('missing'); const c=await pool.connect(); try{ const r=await c.query('insert into authz.route_registry(id,method,path,domain,resource_type,action_name,resource_param) values (coalesce($1,gen_random_uuid()),$2,$3,$4,$5,$6,$7) on conflict (method,path) do update set domain=excluded.domain, resource_type=excluded.resource_type, action_name=excluded.action_name, resource_param=excluded.resource_param returning id,method,path,domain,resource_type,action_name,resource_param',[id||null, method.toUpperCase(), path, domain, resource_type, action_name, resource_param||null]); await audit(req as any,'upsert','authz.route', r.rows[0]?.id, null, r.rows[0]); return r.rows[0] } finally{ c.release() } }
  @Delete('routes/:id') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' })
  async deleteRoute(@Param('id') id:string, @Query('nodeId') _nodeId?:string, req?:any){ const c=await pool.connect(); try{ const before=(await c.query('select * from authz.route_registry where id=$1',[id])).rows[0]; await c.query('delete from authz.route_registry where id=$1',[id]); await audit(req as any,'delete','authz.route', id, before, null); return { ok:true } } finally{ c.release() } }
  
  // Templates CRUD (email/sms)
  @Get('templates/email') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' })
  async listEmailTemplates(@Query('key') key?: string, @Query('client_id') client_id?: string){ const c=await pool.connect(); try{ const args:any[]=[]; let sql='select id, key, client_id, subject, body, created_at, updated_at from email_templates'; const cond:string[]=['deleted_at is null']; if (key){ args.push(key); cond.push(`key=$${args.length}`) } if (client_id){ args.push(client_id); cond.push(`client_id=$${args.length}`) } if (cond.length) sql+=' where '+cond.join(' and '); sql+=' order by key, client_id nulls first'; const r=await c.query(sql,args); return { rows:r.rows } } finally{ c.release() } }
  @Post('templates/email') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' })
  async upsertEmailTemplate(@Body() b:any, req?: any){ const { id, key, client_id, subject, body }=b||{}; if(!key||!subject||!body) throw new BadRequestException('key, subject, body required'); const c=await pool.connect(); try{ const r=await c.query('insert into email_templates(id,key,client_id,subject,body) values (coalesce($1,gen_random_uuid()),$2,$3,$4,$5) on conflict (id) do update set key=excluded.key, client_id=excluded.client_id, subject=excluded.subject, body=excluded.body, updated_at=now() returning id,key,client_id,subject,body',[id||null,key,client_id||null,subject,body]); await audit(req as any,'upsert','template.email', r.rows[0]?.id, null, r.rows[0]); return r.rows[0] } finally{ c.release() } }
  @Delete('templates/email/:id') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' })
  async delEmailTemplate(@Param('id') id:string, req?: any){ const c=await pool.connect(); try{ const before=(await c.query('select * from email_templates where id=$1',[id])).rows[0]; await c.query('delete from email_templates where id=$1',[id]); await audit(req as any,'delete','template.email', id, before, null); return { ok:true } } finally{ c.release() } }

  @Get('templates/sms') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' })
  async listSmsTemplates(@Query('key') key?: string, @Query('client_id') client_id?: string){ const c=await pool.connect(); try{ const args:any[]=[]; let sql='select id, key, client_id, body, created_at, updated_at from sms_templates'; const cond:string[]=[]; if (key){ args.push(key); cond.push(`key=$${args.length}`) } if (client_id){ args.push(client_id); cond.push(`client_id=$${args.length}`) } if (cond.length) sql+=' where '+cond.join(' and '); sql+=' order by key, client_id nulls first'; const r=await c.query(sql,args); return { rows:r.rows } } finally{ c.release() } }
  @Post('templates/sms') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' })
  async upsertSmsTemplate(@Body() b:any, req?: any){ const { id, key, client_id, body }=b||{}; if(!key||!body) throw new BadRequestException('key, body required'); const c=await pool.connect(); try{ const r=await c.query('insert into sms_templates(id,key,client_id,body) values (coalesce($1,gen_random_uuid()),$2,$3,$4) on conflict (id) do update set key=excluded.key, client_id=excluded.client_id, body=excluded.body, updated_at=now() returning id,key,client_id,body',[id||null,key,client_id||null,body]); await audit(req as any,'upsert','template.sms', r.rows[0]?.id, null, r.rows[0]); return r.rows[0] } finally{ c.release() } }
  @Delete('templates/sms/:id') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' })
  async delSmsTemplate(@Param('id') id:string, req?: any){ const c=await pool.connect(); try{ const before=(await c.query('select * from sms_templates where id=$1',[id])).rows[0]; await c.query('delete from sms_templates where id=$1',[id]); await audit(req as any,'delete','template.sms', id, before, null); return { ok:true } } finally{ c.release() } }

  // Service configuration (encrypted)
  @Get('services/configs') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' })
  async listServiceConfigs(@Query('nodeId') nodeId?:string, @Query('service') service?:string, @Query('client_id') client_id?:string){ const c=await pool.connect(); try{ const args:any[]=[nodeId||null]; let sql='select id, org_id, client_id, service, name, created_at, updated_at from service_configs where org_id=$1'; if(service){ args.push(service); sql+=' and service=$2' } if(client_id){ args.push(client_id); sql+= service? ' and client_id=$3':' and client_id=$2' } sql+=' order by service, name'; const r=await c.query(sql,args); return { rows:r.rows } } finally { c.release() } }
  @Post('services/configs') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' })
  async upsertServiceConfig(@Body() b:any, @Query('nodeId') nodeId?:string, req?: any){ const { id, service, name, value, client_id }=b||{}; if(!service||!name||typeof value!=='string') throw new BadRequestException('service, name, value required'); const secret=process.env.AUTH_SECRET||'dev-secret-change-me'; const value_enc=enc(value, secret); const c=await pool.connect(); try{ const r=await c.query('insert into service_configs(id,org_id,client_id,service,name,value_enc) values (coalesce($1,gen_random_uuid()),$2,$3,$4,$5,$6) on conflict (org_id,client_id,service,name) do update set value_enc=excluded.value_enc, updated_at=now() returning id, org_id, client_id, service, name, created_at, updated_at',[id||null, nodeId, client_id||null, service, name, value_enc as any]); await audit(req as any,'upsert','service.config', r.rows[0]?.id, null, { service, name, client_id: client_id||null }); return r.rows[0] } finally { c.release() } }
  @Delete('services/configs/:id') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' })
  async delServiceConfig(@Param('id') id:string, req?: any){ const c=await pool.connect(); try{ const before=(await c.query('select * from service_configs where id=$1',[id])).rows[0]; await c.query('update service_configs set deleted_at=now() where id=$1',[id]); await audit(req as any,'delete','service.config', id, before, null); return { ok:true } } finally { c.release() } }

  // Budget
  @Get('budget') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' })
  async getBudget(@Query('nodeId') nodeId?: string){ const c=await pool.connect(); try{ const r=await c.query('select monthly_limit_usd from budgets where org_id=$1',[nodeId]); return { monthly_limit_usd: r.rows[0]?.monthly_limit_usd || 0 } } finally { c.release() } }
  @Post('budget') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' })
  async setBudget(@Query('nodeId') nodeId?:string, @Body() b?:any){ const limit = Number(b?.monthly_limit_usd || 0); const c=await pool.connect(); try{ await c.query('insert into budgets(org_id, monthly_limit_usd) values ($1,$2) on conflict (org_id) do update set monthly_limit_usd=excluded.monthly_limit_usd, updated_at=now()',[nodeId, limit]); return { ok:true } } finally { c.release() } }
  // Roles
  @Get('roles') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async listRoles(@Query('nodeId') _nodeId?:string, @Query('q') q?:string, @Query('limit') limit?:string, @Query('offset') offset?:string){ const c=await pool.connect(); try{ const lim=Math.max(1, Math.min(200, Number(limit||'20'))); const off=Math.max(0, Number(offset||'0')); let sql='select id,name,level from authz.roles'; const args:any[]=[]; if (q){ args.push(`%${q.toLowerCase()}%`); sql+=' where lower(name) like $1' } sql+=' order by level desc limit '+lim+' offset '+off; const r=await c.query(sql,args); return { rows:r.rows, limit: lim, offset: off, q: q||'' } } finally{ c.release() } }
  @Post('roles') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async createRole(@Body() b:any, @Query('nodeId') _nodeId?:string, @Param() _p?:any, @Query() _q?:any, @Body() _body2?:any, req?:any){ const { id,name,level }=b||{}; if(!name||typeof level!=='number') throw new BadRequestException('name, level required'); const c=await pool.connect(); try{ const r=await c.query('insert into authz.roles(id,name,level) values (coalesce($1,gen_random_uuid()),$2,$3) returning id,name,level',[id||null,name,level]); await audit(req as any,'create','authz.role',r.rows[0]?.id,null,r.rows[0]); return r.rows[0] } finally{ c.release() } }
  @Patch('roles/:id') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async updateRole(@Param('id') id:string,@Body() b:any, @Query('nodeId') _nodeId?:string, req?:any){ const { name,level }=b||{}; if(!name&&typeof level!=='number') throw new BadRequestException('nothing to update'); const c=await pool.connect(); try{ const before = (await c.query('select id,name,level from authz.roles where id=$1',[id])).rows[0]; const r=await c.query('update authz.roles set name=coalesce($2,name), level=coalesce($3,level) where id=$1 returning id,name,level',[id,name||null,typeof level==='number'?level:null]); const row=r.rows[0]; if(!row) throw new BadRequestException('not found'); await audit(req as any,'update','authz.role',id,before,row); return row } finally{ c.release() } }
  @Delete('roles/:id') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async deleteRole(@Param('id') id:string, @Query('nodeId') _nodeId?:string, req?:any){ const c=await pool.connect(); try{ const before=(await c.query('select id,name,level from authz.roles where id=$1',[id])).rows[0]; await c.query('delete from authz.roles where id=$1',[id]); await audit(req as any,'delete','authz.role',id,before,null); return { ok:true } } finally{ c.release() } }

  // Actions
  @Get('actions') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async listActions(@Query('nodeId') _nodeId?:string, @Query('q') q?:string, @Query('limit') limit?:string, @Query('offset') offset?:string){ const c=await pool.connect(); try{ const lim=Math.max(1, Math.min(200, Number(limit||'20'))); const off=Math.max(0, Number(offset||'0')); let sql='select name from authz.actions'; const args:any[]=[]; if (q){ args.push(`%${q.toLowerCase()}%`); sql+=' where lower(name) like $1' } sql+=' order by name asc limit '+lim+' offset '+off; const r=await c.query(sql,args); return { rows:r.rows, limit: lim, offset: off, q: q||'' } } finally{ c.release() } }
  @Post('actions') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async createAction(@Body() b:any, @Query('nodeId') _nodeId?:string, req?:any){ const { name }=b||{}; if(!name) throw new BadRequestException('name required'); const c=await pool.connect(); try{ const r=await c.query('insert into authz.actions(name) values ($1) on conflict do nothing returning name',[name]); await audit(req as any,'create','authz.action',name,null,r.rows[0]||{name}); return r.rows[0]||{name} } finally{ c.release() } }
  @Delete('actions/:name') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async deleteAction(@Param('name') name:string, @Query('nodeId') _nodeId?:string, req?:any){ const c=await pool.connect(); try{ await c.query('delete from authz.actions where name=$1',[name]); await audit(req as any,'delete','authz.action',name,null,null); return { ok:true } } finally{ c.release() } }

  // Permissions
  @Get('permissions') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async listPerms(@Query('nodeId') _nodeId?:string, @Query('q') q?:string, @Query('limit') limit?:string, @Query('offset') offset?:string){ const c=await pool.connect(); try{ const lim=Math.max(1, Math.min(200, Number(limit||'20'))); const off=Math.max(0, Number(offset||'0')); let sql='select id,domain,resource_type,action_name,min_role_id from authz.permissions'; const args:any[]=[]; if (q){ args.push(`%${q.toLowerCase()}%`); sql+=" where lower(domain)||'.'||lower(resource_type)||'.'||lower(action_name) like $1" } sql+=' order by domain,resource_type,action_name limit '+lim+' offset '+off; const r=await c.query(sql,args); return { rows:r.rows, limit: lim, offset: off, q: q||'' } } finally{ c.release() } }
  @Post('permissions') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async createPerm(@Body() b:any, @Query('nodeId') _nodeId?:string, req?:any){ const { id,domain,resource_type,action_name,min_role_id }=b||{}; if(!domain||!resource_type||!action_name||!min_role_id) throw new BadRequestException('missing fields'); const c=await pool.connect(); try{ const before=(await c.query('select id,domain,resource_type,action_name,min_role_id from authz.permissions where domain=$1 and resource_type=$2 and action_name=$3',[domain,resource_type,action_name])).rows[0]; const r=await c.query('insert into authz.permissions(id,domain,resource_type,action_name,min_role_id) values (coalesce($1,gen_random_uuid()),$2,$3,$4,$5) on conflict (domain,resource_type,action_name) do update set min_role_id=excluded.min_role_id returning id,domain,resource_type,action_name,min_role_id',[id||null,domain,resource_type,action_name,min_role_id]); await audit(req as any, before? 'update':'create','authz.permission', r.rows[0]?.id, before, r.rows[0]); return r.rows[0] } finally{ c.release() } }
  @Patch('permissions/:id') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async updatePerm(@Param('id') id:string,@Body() b:any, @Query('nodeId') _nodeId?:string, req?:any){ const { min_role_id }=b||{}; if(!min_role_id) throw new BadRequestException('min_role_id required'); const c=await pool.connect(); try{ const before=(await c.query('select id,domain,resource_type,action_name,min_role_id from authz.permissions where id=$1',[id])).rows[0]; const r=await c.query('update authz.permissions set min_role_id=$2 where id=$1 returning id,domain,resource_type,action_name,min_role_id',[id,min_role_id]); const row=r.rows[0]; if(!row) throw new BadRequestException('not found'); await audit(req as any,'update','authz.permission',id,before,row); return row } finally{ c.release() } }
  @Delete('permissions/:id') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async deletePerm(@Param('id') id:string, @Query('nodeId') _nodeId?:string, req?:any){ const c=await pool.connect(); try{ const before=(await c.query('select id,domain,resource_type,action_name,min_role_id from authz.permissions where id=$1',[id])).rows[0]; await c.query('delete from authz.permissions where id=$1',[id]); await audit(req as any,'delete','authz.permission',id,before,null); return { ok:true } } finally{ c.release() } }

  // Role assignments
  @Get('assignments') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async listAssignments(@Query('userId') userId?:string,@Query('nodeId') nodeId?:string, @Query('limit') limit?:string, @Query('offset') offset?:string){ const c=await pool.connect(); try{ const lim=Math.max(1, Math.min(200, Number(limit||'20'))); const off=Math.max(0, Number(offset||'0')); let where=''; const args:any[]=[]; if(userId){args.push(userId); where+=' where user_id=$'+args.length} if(nodeId){args.push(nodeId); where+=(where?' and':' where')+' node_id=$'+args.length} const r=await c.query(`select id,user_id,node_id,role_id,constraints from authz.role_assignments${where} order by user_id,node_id limit ${lim} offset ${off}`,args); return { rows:r.rows, limit:lim, offset:off } } finally{ c.release() } }
  @Post('assignments') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async createAssignment(@Body() b:any, @Query('nodeId') _nodeId?:string, req?:any){ const { id,user_id,node_id,role_id,constraints }=b||{}; if(!user_id||!node_id||!role_id) throw new BadRequestException('missing fields'); const c=await pool.connect(); try{ const r=await c.query('insert into authz.role_assignments(id,user_id,node_id,role_id,constraints) values (coalesce($1,gen_random_uuid()),$2,$3,$4,coalesce($5,\'{}\'::jsonb)) on conflict do nothing returning id,user_id,node_id,role_id,constraints',[id||null,user_id,node_id,role_id,JSON.stringify(constraints||{})]); const out = r.rows[0] || { id, user_id, node_id, role_id, constraints: constraints || {} }; await audit(req as any,'create','authz.role_assignment', out.id, null, out); return out } finally{ c.release() } }
  @Delete('assignments/:id') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async deleteAssignment(@Param('id') id:string, @Query('nodeId') _nodeId?:string, req?:any){ const c=await pool.connect(); try{ const before=(await c.query('select * from authz.role_assignments where id=$1',[id])).rows[0]; await c.query('delete from authz.role_assignments where id=$1',[id]); await audit(req as any,'delete','authz.role_assignment', id, before, null); return { ok:true } } finally{ c.release() } }

  // ABAC fences
  @Get('abac') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async listAbac(@Query('nodeId') _nodeId?:string){ const c=await pool.connect(); try{ const r=await c.query('select id,action_name,expr from authz.abac_fences order by action_name'); return { rows:r.rows } } finally{ c.release() } }
  @Post('abac') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async createAbac(@Body() b:any, @Query('nodeId') _nodeId?:string, req?:any){ const { id,action_name,expr }=b||{}; if(!action_name||!expr) throw new BadRequestException('missing fields'); const c=await pool.connect(); try{ const r=await c.query('insert into authz.abac_fences(id,action_name,expr) values (coalesce($1,gen_random_uuid()),$2,$3::jsonb) returning id,action_name,expr',[id||null,action_name,JSON.stringify(expr)]); await audit(req as any,'create','authz.abac',r.rows[0]?.id,null,r.rows[0]); return r.rows[0] } finally{ c.release() } }
  @Patch('abac/:id') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async updateAbac(@Param('id') id:string,@Body() b:any, @Query('nodeId') _nodeId?:string, req?:any){ const { expr }=b||{}; if(!expr) throw new BadRequestException('expr required'); const c=await pool.connect(); try{ const before=(await c.query('select * from authz.abac_fences where id=$1',[id])).rows[0]; const r=await c.query('update authz.abac_fences set expr=$2::jsonb where id=$1 returning id,action_name,expr',[id,JSON.stringify(expr)]); const row=r.rows[0]; if(!row) throw new BadRequestException('not found'); await audit(req as any,'update','authz.abac',id,before,row); return row } finally{ c.release() } }
  @Delete('abac/:id') @Authz({ action:'configure', domain:'node', resourceType:'org', resourceParam:'nodeId' }) async deleteAbac(@Param('id') id:string, @Query('nodeId') _nodeId?:string, req?:any){ const c=await pool.connect(); try{ const before=(await c.query('select * from authz.abac_fences where id=$1',[id])).rows[0]; await c.query('delete from authz.abac_fences where id=$1',[id]); await audit(req as any,'delete','authz.abac',id,before,null); return { ok:true } } finally{ c.release() } }
}
